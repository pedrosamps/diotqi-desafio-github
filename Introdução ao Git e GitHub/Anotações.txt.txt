o	INTRODUÇÃO AO GIT E AO GITHUB
	Entendendo o que é Git e sua importância: Git e github são coisas diferentes e meramente complementares. Iremos aprender sobre controle de versão, armazenamento em nuvem, trabalho em equipe, melhorar seu código e reconhecimento. 
	Comandos básicos para um bom desempenho no terminal: 
	Aprendizado: Mudar de pastas, listar as pastas, criar/deletar pastas/arquivos. Os usuários que utilizam o sistema operacional Windows vão interagir e rodar alguns comandos de forma diferente no terminal de usuários que tem outros sistemas operacionais. 
Windows - digite “cmd” (prompt de comando) para abrir o terminal Windows > dentro do terminal digite “dir” para abrir uma lista de diretórios contidos na pasta do código situado (ou seja, dentro do usuário) > próximo comando é o “change directory”, ou “cd”. Esse comando vai possibilitar que a gente navegue entre as pastas, ele é igual para todos os sistemas operacionais. Se eu digitar “cd /”, ele vai nos levar para a base do diretório C:\.  Se eu usar novamente o comando “dir”, ele vai listar as pastas presentes aqui no diretório C:\ > E se eu quiser entrar na pasta Windows, digitarei “cd Windows” para entrar na pasta. O comando vai trazer todos os arquivos/programas/pastas contidos dentro da pasta Windows > Para retroceder um nível na navegado, digite “cd ..”para retornar a base do diretório > Para limpar a tela do terminal, digite “cls” que significa clear screen > Se digitar “cd w” e apertar o botão TAB ele vai reconhecer a pasta em que estou vai auto completar para mim > Para CRIAR uma pasta, utilize o comando “mkdir” de make directory e por padrão vou criar uma pasta chamada workspace > se deu tudo certo o terminal não vai te falar nada, chamado “silence for sucess” > se eu digitar o “dir” novamente, ele vai me trazer a lista de diretórios contidos dentro dessa pasta > digite cd workspace (pasta criada) para entrar na pastar criada > Use o comando “echo” e ele vai printar de volta no termina uma frase. Digite “echo hello”, o sistema vai te devolver o hello. Em seguida use o “echo hello >”, o símbolo é um redirecionador de fluxo, ele vai pegar o output(saída) dessa função echo e vai jogar em um arquivo. Digite “echo hello > hello.txt” (o sistema operacional vai chegar se essa pasta já existe, caso não exista já será criado a pasta para o usuário > acontecerá o silence for sucess e em seguida digite “dir” para abrir o arquivo hello.txt > quando sair da pasta após o “cd...” e em seguida limpar com “clr”, digite o “dir” para abrir os arquivos > digite “del” ... [nome do arquivo]. O sistema vai perguntar se quer deletar ou não. Quando reiniciar tudo e reabrir o “dir”, a pasta ainda está lá. No Windows tem uma diferença entre deletar ARQUIVOS e deletar REPOSITÓRIOS. O comando del se restringe apenas a deletar ARQUIVOS. Então se digitarmos “cd workspace” e em seguida “dir” vai mostrar a pasta vazia > Para deletar um repositório eu usarei o comando “up” da tecla de direções no teclado para navegar entre o histórico de comandos que digite no terminal > procure o comando utilizado para criar a pasta hello.txt em seguida digite “dir”, em seguida saia da pasta com o comando “cd ..” > “cls” > “dir” para verificar novamente todos os arquivos existentes. Para enfim deletar o repositório digite “rmdir” ... [nome do arquivo]  ... [/S /Q]  > digite “dir” para reabrir todos os arquivos e verá que foi excluído a pasta workspace
Linux – digite “ls” para abrir uma lista de diretórios contidos na pasta em que estamos situados > > próximo comando é o “change directory”, ou “cd”. Esse comando vai possibilitar que a gente navegue entre as pastas, ele é igual para todos os sistemas operacionais. Se eu digitar “cd /”, ele vai nos levar para a base do diretório C:\.  > digita “cd etc” (pasta do sistema operacional Linux) e posteriormente usar o “ls” para poder listar, vai me trazer todos os programas executáveis, scripts, entre outros contidos na pasta etc > Para retroceder um nível na navegado, digite “cd ..” > Para limpar a tela do terminal, digite “clear” ou apertar ctrl + L, vai limpar igualmente a tela > Para abrir uma nova pasta no Linux, digite “mkdir” e digite o nome da pasta logo em seguida para o silence for sucess >  digite “echo hello > hello.txt > digite “ls” para abrir a pasta > rm –rf para deletar o repositório. 
Todos os comandos usados acima possuem variâncias, então eles possuem “flags” que são complementos que a gente para esses comandos onde eles acrescentam/modificam a forma como esses comandos são devolvidos para a gente. 

	Realizando a instalação do GIT: ------------------

o	ENTENDENDO COMO O GIT FUNCIONA POR DEBAIXO DOS PANOS
	Tópicos fundamentais para entender o funcionamento do Git: 
	SHA1:  A sigla SHA significa “Secure Hash Algorithm”, é um conjunto de funções hash criptográficas projetadas pela SNA (Agência de segurança nacional dos EUA). É importante pois a saída dessa encriptação, esses dados encriptados geram um conjunto de caractere de 40 dígitos. Esse conjunto de caracteres de 40 dígitos são únicos e servem como uma identificação. Por exemplo – se você tem um arquivo de texto muito grande e você vai nesse arquivo de texto e roda o algoritmo, ele vai gerar um conjunto de caracteres de 40 dígitos para o usuário. Se eu for novamente no arquivo e realizar uma única alteração, por menor que seja, e rodar o algoritmo, ele vai gerar OUTRO conjunto de caracteres de 40 dígitos. E assim sucessivamente a cada alteração.  O git faz uso desse algoritmo de encriptação para poder identificar os arquivos de uma forma segura e identificar de uma forma rápida que os arquivos sofreu modificação. 
	Objetos fundamentais: Temos 03 objetos – Blobs (Os arquivos ficam guardados dentro desse objeto. Esse objeto contém metadados dentro dele. Então, o objeto blob vai ter o tipo de objeto, o tamanho da string/arquivo \O e o conteúdo desse arquivo), Trees (A tree armazena blob. Também contém metadado, também contém a \O, ela aponta para um blob que contém um sha1. A trees também guarda o nome desse arquivo. A trees vai ser responsável por montar toda a estrutura e onde está localizado os arquivos. Podem apontar tanto para blobs que são “arquivo”, como outras arvores. Porque o comportamento é dessa forma?  Porque o diretório de um sistema operacional pode conter outros diretórios. A tree por sua vez tem sha1 dentro desse metadado. As blobs possuem um sha1 do arquivo, a tree aponta para a blob e tem o sha1 encriptado os metadados das tree. Se mudar alguma coisa da tree, quando for gerar o sha1 desses metadados, o sha1 da blob vai alterado e consequentemente vai refletir o sha1 da tree. Uma coisa está relacionada a outra) e Commits (É o objeto mais importante entre os citados. É o objeto que vai juntar tudo e dar sentido para alteração que estamos fazendo. Quando o commit aponta para uma tree, ele aponta para um ‘parente’, ou seja, ele aponta para o último commit realizado antes dele. O commit aponta para o autor e para uma mensagem também. O commit possui um timestamp que funciona como um carimbo que leva a data e hora de quando foi criado. Commit também possui um sha1, isto é, também possui encriptação que é a geração desse hash de 40 dígitos identificador do seus metadados. Se eu alterar uma blob, será gerado um sha1 da blob, por sua vez vai alterar os metadados da tree e o commit aponta para uma tree que pode apontar para outras tree, logo isso refletir em tudo. Quando temos um commit, estamos garantindo que ninguém alterou o commit analisando o histórico). 
	Sistema distribuído: Imagine que tenho o meu código/repositório hosteado em um servidor na nuvem. Entao o código que temos representa o estado final do código, do software, sendo a versão mais recente. Entao vamos supor que esse repositório tenha mais de 30 pessoas contribuindo com ele que mantém o código de forma regula, também possuem uma versão desse código. Entao, pelo fato dos commits serem tao difíceis de se alterar. 
	Segurança: 
	Chave SSH e Token: Qualquer projeto que colocarmos no github, devemos autenticar para comprovar que somos o autor do projeto. 
	Chave SSH: Forma de estabelecer segura e incrementada entre 02 máquinas. Github versus sua máquina. 
	OBS: Para esclarecer eventuais dúvidas, pesquise pelo GitHub Docs. 
	Token de acesso pessoal: 

o	Primeiros comandos com Git
	Iniciando o Git e criando um Commit: Com os comandos vamos iniciar o repositório GIT, iniciar o versionamento e criar um commit. Usaremos o “git init” para mover arquivos e dar inicio ao versionamento. Usaremos também o “git add” e o “git commit” para criar o primeiro commit.
Mkdir livro-receitas > ls > cd livro-receitas > git init > ls > ls –a (Como podemos ver a pasta que fica no git gerencial? Usa esse comando que tem uma flag para mostrar arquivos ocultos) > vai mostrar o arquivo oculto da pasta gerencial do git. Se eu entrar na pasta do .git/ e em seguida usar o ls, veremos que já tem uma estrutura dentro referentes ao próprio git.

•	Ciclo de vida dos arquivos no Git
o	Passo a passo no ciclo de vida: 
	Tracked e Untracked: Dentros do tracked, dentro dos arquivos que são rastreáveis pelo git, ele pode ser subdividido em 03 estágios diferentes – unmodified (Arquivo que ainda NÃO foi modificado), modified (É o arquivo unmodified que sofreu alteração) e staged (É onde ficam os arquivos que estão se preparando para poder fazer parte de um outro tipo de agrupamento). Untracked são os arquivos que o git ainda não tem conhecimento. Tracked são os arquivos que o git tem conhecimento. 
Quando utilizamos o git add, teve o seguinte processo: Existia um arquivo ‘untracked’ pois tínhamos acabado de criar ele. O arquivo foi movido do untracked direto para o stage através do git add. // Os arquivos unmodified se trata de ter um arquivo dentro do repositório do git que ainda não sofreu modificação, após a modificado é alterado para modified. Se rodarmos o git add novamente, ele vai para o stage. Ele entra nessa área especial que está aguardando para entrar em ação. Quando se transforma em commit, ele retorna para unmodified, aguardando novas modificações. // O comando git status vai nos ajudar a monitorar o estado dos arquivos, nos informando se está ‘untracked’, ‘modified’ ou ‘staged’. 
Repositório – 
